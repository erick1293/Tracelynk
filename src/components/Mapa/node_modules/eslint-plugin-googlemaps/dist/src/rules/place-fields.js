"use strict";
/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a;
exports.__esModule = true;
exports.messageId = void 0;
var rules_1 = require("../utils/rules");
exports.messageId = (0, rules_1.camelCased)(__filename);
var description = "Use the `fields` option to limit the fields returned by the API and costs. Requests to the Places API are billed by the fields that are returned. See [Places Data SKUs](https://developers.google.com/maps/documentation/places/web-service/usage-and-billing#data-skus) for more details.\n\nMore information about fields for specific API calls can be found at the following links:\n\n- [Place Details fields guidance](https://goo.gle/3H0TxxG)\n- [Place Autocomplete fields guidance](https://goo.gle/3sp2XyS)\n\n> **Note**: This rule is not exhaustive. For example, it ignores `Autocomplete.setFields()`.";
exports["default"] = (0, rules_1.createRule)({
    name: __filename,
    meta: {
        docs: {
            description: description,
            recommended: false
        },
        messages: (_a = {},
            _a[exports.messageId] = "Use the `fields` option to limit the fields returned by the API and costs.",
            _a),
        schema: [],
        type: "suggestion",
        fixable: "code"
    },
    defaultOptions: [],
    create: function (context) {
        return {
            NewExpression: function (node) {
                try {
                    if (fullNamespace(node.callee).match(/google\.maps\.places\.Autocomplete$/)) {
                        var references = context.getScope().references;
                        var options = node.arguments[1];
                        if (objectMaybeHasKey(references, options) === Ternary.FALSE) {
                            context.report({
                                messageId: exports.messageId,
                                node: options || node
                            });
                        }
                    }
                }
                catch (e) {
                    console.warn("rule googlemaps/".concat(__filename, " failed with: ").concat(e));
                }
            },
            MemberExpression: function (node) {
                try {
                    if (node.property.type === "Identifier" &&
                        node.property.name === "getDetails") {
                        if (node.object.type === "Identifier") {
                            var references = context.getScope().references;
                            var name = node.object.name;
                            var service = getReference(references, name);
                            if (service &&
                                service.writeExpr &&
                                service.writeExpr.type === "NewExpression") {
                                if (fullNamespace(service.writeExpr.callee).match(/google\.maps\.places\.PlacesService/)) {
                                    var parent = node.parent;
                                    if (parent && parent.type === "CallExpression") {
                                        var requestArgument_1 = parent.arguments[0];
                                        if (objectMaybeHasKey(references, requestArgument_1) ===
                                            Ternary.FALSE) {
                                            context.report({
                                                messageId: exports.messageId,
                                                node: node.property,
                                                fix: requestArgument_1.type === "ObjectExpression"
                                                    ? function (fixer) {
                                                        return [
                                                            fixer.insertTextBefore(context
                                                                .getSourceCode()
                                                                .getTokens(requestArgument_1)[1], "fields: /** TODO: Add necessary fields to the request */ [], "),
                                                        ];
                                                    }
                                                    : null
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                catch (e) {
                    console.warn("rule googlemaps/".concat(__filename, " failed with: ").concat(e));
                }
            }
        };
    }
});
var fullNamespace = function (node) {
    if (isIdentifier(node)) {
        return node.name;
    }
    if (isMemberExpression(node)) {
        if (node.object.type === "Identifier") {
            return [node.object.name, fullNamespace(node.property)].join(".");
        }
        else if (node.object.type === "MemberExpression") {
            return [fullNamespace(node.object), fullNamespace(node.property)].join(".");
        }
    }
    return "";
};
var isIdentifier = function (node) {
    return node != null && node.type === "Identifier";
};
var isLiteral = function (node) {
    return node != null && node.type === "Literal";
};
var isMemberExpression = function (node) {
    return node != null && node.type === "MemberExpression";
};
var getReference = function (references, name) {
    return references.find(function (_a) {
        var identifier = _a.identifier;
        return identifier.name === name;
    });
};
var Ternary;
(function (Ternary) {
    Ternary[Ternary["TRUE"] = 0] = "TRUE";
    Ternary[Ternary["FALSE"] = 1] = "FALSE";
    Ternary[Ternary["UNKNOWN"] = 2] = "UNKNOWN";
})(Ternary || (Ternary = {}));
var objectMaybeHasKey = function (references, obj) {
    if (!obj) {
        return Ternary.FALSE;
    }
    switch (obj.type) {
        case "Identifier": {
            var resolved = getReference(references, obj.name);
            if (!resolved) {
                return Ternary.UNKNOWN;
            }
            return objectMaybeHasKey(references, resolved.writeExpr);
        }
        case "ObjectExpression": {
            var properties = obj.properties.map(function (property) {
                switch (property.type) {
                    case "Property": {
                        if (isIdentifier(property.key)) {
                            if (property.key.name === "fields") {
                                return Ternary.TRUE;
                            }
                            return Ternary.FALSE;
                        }
                        if (isLiteral(property.key)) {
                            if (property.key.value === "fields") {
                                return Ternary.TRUE;
                            }
                            return Ternary.FALSE;
                        }
                        return Ternary.UNKNOWN;
                    }
                    case "SpreadElement": {
                        return objectMaybeHasKey(references, property.argument);
                    }
                    default: {
                        return Ternary.UNKNOWN;
                    }
                }
            });
            // if at least one Ternary.TRUE
            if (properties.includes(Ternary.TRUE)) {
                return Ternary.TRUE;
            }
            // if all are Ternary.FALSE, we can be certain it is missing
            if (properties.filter(function (t) { return t === Ternary.FALSE; }).length ===
                properties.length) {
                return Ternary.FALSE;
            }
            // fallback to Ternary.Unknown
            return Ternary.UNKNOWN;
        }
        default:
            return Ternary.UNKNOWN;
    }
};
